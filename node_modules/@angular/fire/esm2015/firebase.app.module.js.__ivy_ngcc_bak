/**
 * @fileoverview added by tsickle
 * Generated from: firebase.app.module.ts
 * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingRequire,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc
 */
import { Inject, InjectionToken, isDevMode, NgModule, NgZone, Optional, PLATFORM_ID, VERSION as NG_VERSION, Version } from '@angular/core';
import firebase from 'firebase/app';
/**
 * @record
 */
export function FirebaseOptions() { }
/**
 * @record
 */
export function FirebaseAppConfig() { }
/** @type {?} */
export const FIREBASE_OPTIONS = new InjectionToken('angularfire2.app.options');
/** @type {?} */
export const FIREBASE_APP_NAME = new InjectionToken('angularfire2.app.nameOrConfig');
// Have to implement as we need to return a class from the provider, we should consider exporting
// this in the firebase/app types as this is our highest risk of breaks
export class FirebaseApp {
}
if (false) {
    /** @type {?} */
    FirebaseApp.prototype.name;
    /** @type {?} */
    FirebaseApp.prototype.options;
    /** @type {?} */
    FirebaseApp.prototype.analytics;
    /** @type {?} */
    FirebaseApp.prototype.auth;
    /** @type {?} */
    FirebaseApp.prototype.database;
    /** @type {?} */
    FirebaseApp.prototype.messaging;
    /** @type {?} */
    FirebaseApp.prototype.performance;
    /** @type {?} */
    FirebaseApp.prototype.storage;
    /** @type {?} */
    FirebaseApp.prototype.delete;
    /** @type {?} */
    FirebaseApp.prototype.firestore;
    /** @type {?} */
    FirebaseApp.prototype.functions;
    /** @type {?} */
    FirebaseApp.prototype.remoteConfig;
}
/** @type {?} */
export const VERSION = new Version('6.1.0');
/**
 * @param {?} options
 * @param {?} zone
 * @param {?=} nameOrConfig
 * @return {?}
 */
export function ɵfirebaseAppFactory(options, zone, nameOrConfig) {
    /** @type {?} */
    const name = typeof nameOrConfig === 'string' && nameOrConfig || '[DEFAULT]';
    /** @type {?} */
    const config = typeof nameOrConfig === 'object' && nameOrConfig || {};
    config.name = config.name || name;
    // Added any due to some inconsistency between @firebase/app and firebase types
    /** @type {?} */
    const existingApp = (/** @type {?} */ (firebase.apps.filter((/**
     * @param {?} app
     * @return {?}
     */
    app => app && app.name === config.name))[0]));
    // We support FirebaseConfig, initializeApp's public type only accepts string; need to cast as any
    // Could be solved with https://github.com/firebase/firebase-js-sdk/pull/1206
    /** @type {?} */
    const app = (/** @type {?} */ ((existingApp || zone.runOutsideAngular((/**
     * @return {?}
     */
    () => firebase.initializeApp(options, (/** @type {?} */ (config))))))));
    if (JSON.stringify(options) !== JSON.stringify(app.options)) {
        /** @type {?} */
        const hmr = !!((/** @type {?} */ (module))).hot;
        log('error', `${app.toString()} already initialized with different options${hmr ? ', you may need to reload as Firebase is not HMR aware.' : '.'}`);
    }
    return app;
}
/** @type {?} */
export const ɵlogAuthEmulatorError = (/**
 * @return {?}
 */
() => {
    // TODO sort this out, https://github.com/angular/angularfire/issues/2656
    log('warn', 'You may need to import \'firebase/auth\' manually in your component rather than rely on AngularFireAuth\'s dynamic import, when using the emulator suite https://github.com/angular/angularfire/issues/2656');
});
/** @type {?} */
const log = (/**
 * @param {?} level
 * @param {...?} args
 * @return {?}
 */
(level, ...args) => {
    if (isDevMode() && typeof console !== 'undefined') {
        console[level](...args);
    }
});
const ɵ0 = log;
globalThis.ɵAngularfireInstanceCache || (globalThis.ɵAngularfireInstanceCache = new Map());
/**
 * @template T
 * @param {?} cacheKey
 * @param {?} moduleName
 * @param {?} app
 * @param {?} fn
 * @param {?} args
 * @return {?}
 */
export function ɵfetchInstance(cacheKey, moduleName, app, fn, args) {
    const [instance, ...cachedArgs] = globalThis.ɵAngularfireInstanceCache.get(cacheKey) || [];
    if (instance && args.some((/**
     * @param {?} arg
     * @param {?} i
     * @return {?}
     */
    (arg, i) => {
        /** @type {?} */
        const cachedArg = cachedArgs[i];
        if (arg && typeof arg === 'object') {
            return JSON.stringify(arg) !== JSON.stringify(cachedArg);
        }
        else {
            return arg !== cachedArg;
        }
    }))) {
        /** @type {?} */
        const hmr = !!((/** @type {?} */ (module))).hot;
        log('error', `${moduleName} was already initialized on the ${app.name} Firebase App instance with different settings.${hmr ? ' You may need to reload as Firebase is not HMR aware.' : ''}`);
        return instance;
    }
    else {
        /** @type {?} */
        const newInstance = fn();
        globalThis.ɵAngularfireInstanceCache.set(cacheKey, [newInstance, ...args]);
        return newInstance;
    }
}
/** @type {?} */
const FIREBASE_APP_PROVIDER = {
    provide: FirebaseApp,
    useFactory: ɵfirebaseAppFactory,
    deps: [
        FIREBASE_OPTIONS,
        NgZone,
        [new Optional(), FIREBASE_APP_NAME]
    ]
};
export class AngularFireModule {
    // tslint:disable-next-line:ban-types
    /**
     * @param {?} platformId
     */
    constructor(platformId) {
        firebase.registerVersion('angularfire', VERSION.full, platformId.toString());
        firebase.registerVersion('angular', NG_VERSION.full);
    }
    /**
     * @param {?} options
     * @param {?=} nameOrConfig
     * @return {?}
     */
    static initializeApp(options, nameOrConfig) {
        return {
            ngModule: AngularFireModule,
            providers: [
                { provide: FIREBASE_OPTIONS, useValue: options },
                { provide: FIREBASE_APP_NAME, useValue: nameOrConfig }
            ]
        };
    }
}
AngularFireModule.decorators = [
    { type: NgModule, args: [{
                providers: [FIREBASE_APP_PROVIDER]
            },] }
];
/** @nocollapse */
AngularFireModule.ctorParameters = () => [
    { type: Object, decorators: [{ type: Inject, args: [PLATFORM_ID,] }] }
];
export { ɵ0 };
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiZmlyZWJhc2UuYXBwLm1vZHVsZS5qcyIsInNvdXJjZVJvb3QiOiIvd29ya3NwYWNlL3NyYy9jb3JlLyIsInNvdXJjZXMiOlsiZmlyZWJhc2UuYXBwLm1vZHVsZS50cyJdLCJuYW1lcyI6W10sIm1hcHBpbmdzIjoiOzs7OztBQUFBLE9BQU8sRUFDTCxNQUFNLEVBQUUsY0FBYyxFQUFFLFNBQVMsRUFBdUIsUUFBUSxFQUFFLE1BQU0sRUFBRSxRQUFRLEVBQUUsV0FBVyxFQUFFLE9BQU8sSUFBSSxVQUFVLEVBQUUsT0FBTyxFQUNoSSxNQUFNLGVBQWUsQ0FBQztBQUN2QixPQUFPLFFBQVEsTUFBTSxjQUFjLENBQUM7Ozs7QUFHcEMscUNBRUM7Ozs7QUFFRCx1Q0FFQzs7QUFFRCxNQUFNLE9BQU8sZ0JBQWdCLEdBQUcsSUFBSSxjQUFjLENBQWtCLDBCQUEwQixDQUFDOztBQUMvRixNQUFNLE9BQU8saUJBQWlCLEdBQUcsSUFBSSxjQUFjLENBQXlDLCtCQUErQixDQUFDOzs7QUFJNUgsTUFBTSxPQUFPLFdBQVc7Q0FhdkI7OztJQVpDLDJCQUFhOztJQUNiLDhCQUFZOztJQUNaLGdDQUE4Qzs7SUFDOUMsMkJBQStCOztJQUMvQiwrQkFBK0Q7O0lBQy9ELGdDQUE4Qzs7SUFDOUMsa0NBQW9EOztJQUNwRCw4QkFBOEQ7O0lBQzlELDZCQUE0Qjs7SUFDNUIsZ0NBQThDOztJQUM5QyxnQ0FBNkQ7O0lBQzdELG1DQUF1RDs7O0FBR3pELE1BQU0sT0FBTyxPQUFPLEdBQUcsSUFBSSxPQUFPLENBQUMsc0JBQXNCLENBQUM7Ozs7Ozs7QUFFMUQsTUFBTSxVQUFVLG1CQUFtQixDQUFDLE9BQXdCLEVBQUUsSUFBWSxFQUFFLFlBQWdEOztVQUNwSCxJQUFJLEdBQUcsT0FBTyxZQUFZLEtBQUssUUFBUSxJQUFJLFlBQVksSUFBSSxXQUFXOztVQUN0RSxNQUFNLEdBQUcsT0FBTyxZQUFZLEtBQUssUUFBUSxJQUFJLFlBQVksSUFBSSxFQUFFO0lBQ3JFLE1BQU0sQ0FBQyxJQUFJLEdBQUcs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Q0FBQyxDQUFDO1FBQzNFLE9BQU8sV0FBVyxDQUFDO0tBQ3BCO0FBQ0gsQ0FBQzs7TUFFSyxxQkFBcUIsR0FBRztJQUM1QixPQUFPLEVBQUUsV0FBVztJQUNwQixVQUFVLEVBQUUsbUJBQW1CO0lBQy9CLElBQUksRUFBRTtRQUNKLGdCQUFnQjtRQUNoQixNQUFNO1FBQ04sQ0FBQyxJQUFJLFFBQVEsRUFBRSxFQUFFLGlCQUFpQixDQUFDO0tBQ3BDO0NBQ0Y7QUFLRCxNQUFNLE9BQU8saUJBQWlCOzs7OztJQVk1QixZQUFpQyxVQUFrQjtRQUNqRCxRQUFRLENBQUMsZUFBZSxDQUFDLGFBQWEsRUFBRSxPQUFPLENBQUMsSUFBSSxFQUFFLFVBQVUsQ0FBQyxRQUFRLEVBQUUsQ0FBQyxDQUFDO1FBQzdFLFFBQVEsQ0FBQyxlQUFlLENBQUMsU0FBUyxFQUFFLFVBQVUsQ0FBQyxJQUFJLENBQUMsQ0FBQztJQUN2RCxDQUFDOzs7Ozs7SUFkRCxNQUFNLENBQUMsYUFBYSxDQUFDLE9BQXdCLEVBQUUsWUFBeUM7UUFDdEYsT0FBTztZQUNMLFFBQVEsRUFBRSxpQkFBaUI7WUFDM0IsU0FBUyxFQUFFO2dCQUNULEVBQUMsT0FBTyxFQUFFLGdCQUFnQixFQUFFLFFBQVEsRUFBRSxPQUFPLEVBQUM7Z0JBQzlDLEVBQUMsT0FBTyxFQUFFLGlCQUFpQixFQUFFLFFBQVEsRUFBRSxZQUFZLEVBQUM7YUFDckQ7U0FDRixDQUFDO0lBQ0osQ0FBQzs7O1lBWkYsUUFBUSxTQUFDO2dCQUNSLFNBQVMsRUFBRSxDQUFDLHFCQUFxQixDQUFDO2FBQ25DOzs7O1lBYThDLE1BQU0sdUJBQXRDLE1BQU0sU0FBQyxXQUFXIiwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHtcbiAgSW5qZWN0LCBJbmplY3Rpb25Ub2tlbiwgaXNEZXZNb2RlLCBNb2R1bGVXaXRoUHJvdmlkZXJzLCBOZ01vZHVsZSwgTmdab25lLCBPcHRpb25hbCwgUExBVEZPUk1fSUQsIFZFUlNJT04gYXMgTkdfVkVSU0lPTiwgVmVyc2lvblxufSBmcm9tICdAYW5ndWxhci9jb3JlJztcbmltcG9ydCBmaXJlYmFzZSBmcm9tICdmaXJlYmFzZS9hcHAnO1xuXG4vLyBJTlZFU1RJR0FURSBQdWJsaWMgdHlwZXMgZG9uJ3QgZXhwb3NlIEZpcmViYXNlT3B0aW9ucyBvciBGaXJlYmFzZUFwcENvbmZpZywgaXMgdGhpcyB0aGUgY2FzZSBhbnlsb25nZXI/XG5leHBvcnQgaW50ZXJmYWNlIEZpcmViYXNlT3B0aW9ucyB7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGludGVyZmFjZSBGaXJlYmFzZUFwcENvbmZpZyB7XG4gIFtrZXk6IHN0cmluZ106IGFueTtcbn1cblxuZXhwb3J0IGNvbnN0IEZJUkVCQVNFX09QVElPTlMgPSBuZXcgSW5qZWN0aW9uVG9rZW48RmlyZWJhc2VPcHRpb25zPignYW5ndWxhcmZpcmUyLmFwcC5vcHRpb25zJyk7XG5leHBvcnQgY29uc3QgRklSRUJBU0VfQVBQX05BTUUgPSBuZXcgSW5qZWN0aW9uVG9rZW48c3RyaW5nIHwgRmlyZWJhc2VBcHBDb25maWcgfCB1bmRlZmluZWQ+KCdhbmd1bGFyZmlyZTIuYXBwLm5hbWVPckNvbmZpZycpO1xuXG4vLyBIYXZlIHRvIGltcGxlbWVudCBhcyB3ZSBuZWVkIHRvIHJldHVybiBhIGNsYXNzIGZyb20gdGhlIHByb3ZpZGVyLCB3ZSBzaG91bGQgY29uc2lkZXIgZXhwb3J0aW5nXG4vLyB0aGlzIGluIHRoZSBmaXJlYmFzZS9hcHAgdHlwZXMgYXMgdGhpcyBpcyBvdXIgaGlnaGVzdCByaXNrIG9mIGJyZWFrc1xuZXhwb3J0IGNsYXNzIEZpcmViYXNlQXBwIGltcGxlbWVudHMgUGFydGlhbDxmaXJlYmFzZS5hcHAuQXBwPiB7XG4gIG5hbWU6IHN0cmluZztcbiAgb3B0aW9uczoge307XG4gIGFuYWx5dGljczogKCkgPT4gZmlyZWJhc2UuYW5hbHl0aWNzLkFuYWx5dGljcztcbiAgYXV0aDogKCkgPT4gZmlyZWJhc2UuYXV0aC5BdXRoO1xuICBkYXRhYmFzZTogKGRhdGFiYXNlVVJMPzogc3RyaW5nKSA9PiBmaXJlYmFzZS5kYXRhYmFzZS5EYXRhYmFzZTtcbiAgbWVzc2FnaW5nOiAoKSA9PiBmaXJlYmFzZS5tZXNzYWdpbmcuTWVzc2FnaW5nO1xuICBwZXJmb3JtYW5jZTogKCkgPT4gZmlyZWJhc2UucGVyZm9ybWFuY2UuUGVyZm9ybWFuY2U7XG4gIHN0b3JhZ2U6IChzdG9yYWdlQnVja2V0Pzogc3RyaW5nKSA9PiBmaXJlYmFzZS5zdG9yYWdlLlN0b3JhZ2U7XG4gIGRlbGV0ZTogKCkgPT4gUHJvbWlzZTx2b2lkPjtcbiAgZmlyZXN0b3JlOiAoKSA9PiBmaXJlYmFzZS5maXJlc3RvcmUuRmlyZXN0b3JlO1xuICBmdW5jdGlvbnM6IChyZWdpb24/OiBzdHJpbmcpID0+IGZpcmViYXNlLmZ1bmN0aW9ucy5GdW5jdGlvbnM7XG4gIHJlbW90ZUNvbmZpZzogKCkgPT4gZmlyZWJhc2UucmVtb3RlQ29uZmlnLlJlbW90ZUNvbmZpZztcbn1cblxuZXhwb3J0IGNvbnN0IFZFUlNJT04gPSBuZXcgVmVyc2lvbignQU5HVUxBUkZJUkUyX1ZFUlNJT04nKTtcblxuZXhwb3J0IGZ1bmN0aW9uIMm1ZmlyZWJhc2VBcHBGYWN0b3J5KG9wdGlvbnM6IEZpcmViYXNlT3B0aW9ucywgem9uZTogTmdab25lLCBuYW1lT3JDb25maWc/OiBzdHJpbmcgfCBGaXJlYmFzZUFwcENvbmZpZyB8IG51bGwpIHtcbiAgY29uc3QgbmFtZSA9IHR5cGVvZiBuYW1lT3JDb25maWcgPT09ICdzdHJpbmcnICYmIG5hbWVPckNvbmZpZyB8fCAnW0RFRkFVTFRdJztcbiAgY29uc3QgY29uZmlnID0gdHlwZW9mIG5hbWVPckNvbmZpZyA9PT0gJ29iamVjdCcgJiYgbmFtZU9yQ29uZmlnIHx8IHt9O1xuICBjb25maWcubmFtZSA9IGNvbmZpZy5uYW1lIHx8IG5hbWU7XG4gIC8vIEFkZGVkIGFueSBkdWUgdG8gc29tZSBpbmNvbnNpc3RlbmN5IGJldHdlZW4gQGZpcmViYXNlL2FwcCBhbmQgZmlyZWJhc2UgdHlwZXNcbiAgY29uc3QgZXhpc3RpbmdBcHAgPSBmaXJlYmFzZS5hcHBzLmZpbHRlcihhcHAgPT4gYXBwICYmIGFwcC5uYW1lID09PSBjb25maWcubmFtZSlbMF0gYXMgYW55O1xuICAvLyBXZSBzdXBwb3J0IEZpcmViYXNlQ29uZmlnLCBpbml0aWFsaXplQXBwJ3MgcHVibGljIHR5cGUgb25seSBhY2NlcHRzIHN0cmluZzsgbmVlZCB0byBjYXN0IGFzIGFueVxuICAvLyBDb3VsZCBiZSBzb2x2ZWQgd2l0aCBodHRwczovL2dpdGh1Yi5jb20vZmlyZWJhc2UvZmlyZWJhc2UtanMtc2RrL3B1bGwvMTIwNlxuICBjb25zdCBhcHAgPSAoZXhpc3RpbmdBcHAgfHwgem9uZS5ydW5PdXRzaWRlQW5ndWxhcigoKSA9PiBmaXJlYmFzZS5pbml0aWFsaXplQXBwKG9wdGlvbnMsIGNvbmZpZyBhcyBhbnkpKSkgYXMgRmlyZWJhc2VBcHA7XG4gIGlmIChKU09OLnN0cmluZ2lmeShvcHRpb25zKSAhPT0gSlNPTi5zdHJpbmdpZnkoYXBwLm9wdGlvbnMpKSB7XG4gICAgY29uc3QgaG1yID0gISEobW9kdWxlIGFzIGFueSkuaG90O1xuICAgIGxvZygnZXJyb3InLCBgJHthcHAudG9TdHJpbmcoKX0gYWxyZWFkeSBpbml0aWFsaXplZCB3aXRoIGRpZmZlcmVudCBvcHRpb25zJHtobXIgPyAnLCB5b3UgbWF5IG5lZWQgdG8gcmVsb2FkIGFzIEZpcmViYXNlIGlzIG5vdCBITVIgYXdhcmUuJyA6ICcuJ31gKTtcbiAgfVxuICByZXR1cm4gYXBwO1xufVxuXG5leHBvcnQgY29uc3QgybVsb2dBdXRoRW11bGF0b3JFcnJvciA9ICgpID0+IHtcbiAgLy8gVE9ETyBzb3J0IHRoaXMgb3V0LCBodHRwczovL2dpdGh1Yi5jb20vYW5ndWxhci9hbmd1bGFyZmlyZS9pc3N1ZXMvMjY1NlxuICBsb2coJ3dhcm4nLCAnWW91IG1heSBuZWVkIHRvIGltcG9ydCBcXCdmaXJlYmFzZS9hdXRoXFwnIG1hbnVhbGx5IGluIHlvdXIgY29tcG9uZW50IHJhdGhlciB0aGFuIHJlbHkgb24gQW5ndWxhckZpcmVBdXRoXFwncyBkeW5hbWljIGltcG9ydCwgd2hlbiB1c2luZyB0aGUgZW11bGF0b3Igc3VpdGUgaHR0cHM6Ly9naXRodWIuY29tL2FuZ3VsYXIvYW5ndWxhcmZpcmUvaXNzdWVzLzI2NTYnKTtcbn07XG5cbmNvbnN0IGxvZyA9IChsZXZlbDogJ2xvZyd8J2Vycm9yJ3wnaW5mbyd8J3dhcm4nLCAuLi5hcmdzOiBhbnkpID0+IHtcbiAgaWYgKGlzRGV2TW9kZSgpICYmIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGVbbGV2ZWxdKC4uLmFyZ3MpO1xuICB9XG59O1xuXG5nbG9iYWxUaGlzLsm1QW5ndWxhcmZpcmVJbnN0YW5jZUNhY2hlIHx8PSBuZXcgTWFwKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiDJtWZldGNoSW5zdGFuY2U8VD4oY2FjaGVLZXk6IGFueSwgbW9kdWxlTmFtZTogc3RyaW5nLCBhcHA6IEZpcmViYXNlQXBwLCBmbjogKCkgPT4gVCwgYXJnczogYW55W10pOiBUIHtcbiAgY29uc3QgW2luc3RhbmNlLCAuLi5jYWNoZWRBcmdzXSA9IGdsb2JhbFRoaXMuybVBbmd1bGFyZmlyZUluc3RhbmNlQ2FjaGUuZ2V0KGNhY2hlS2V5KSB8fCBbXTtcbiAgaWYgKGluc3RhbmNlICYmIGFyZ3Muc29tZSgoYXJnLCBpKSA9PiB7XG4gICAgY29uc3QgY2FjaGVkQXJnID0gY2FjaGVkQXJnc1tpXTtcbiAgICBpZiAoYXJnICYmIHR5cGVvZiBhcmcgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYXJnKSAhPT0gSlNPTi5zdHJpbmdpZnkoY2FjaGVkQXJnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGFyZyAhPT0gY2FjaGVkQXJnO1xuICAgIH1cbiAgfSkpIHtcbiAgICBjb25zdCBobXIgPSAhIShtb2R1bGUgYXMgYW55KS5ob3Q7XG4gICAgbG9nKCdlcnJvcicsIGAke21vZHVsZU5hbWV9IHdhcyBhbHJlYWR5IGluaXRpYWxpemVkIG9uIHRoZSAke2FwcC5uYW1lfSBGaXJlYmFzZSBBcHAgaW5zdGFuY2Ugd2l0aCBkaWZmZXJlbnQgc2V0dGluZ3MuJHtobXIgPyAnIFlvdSBtYXkgbmVlZCB0byByZWxvYWQgYXMgRmlyZWJhc2UgaXMgbm90IEhNUiBhd2FyZS4nIDogJyd9YCk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9IGVsc2Uge1xuICAgIGNvbnN0IG5ld0luc3RhbmNlID0gZm4oKTtcbiAgICBnbG9iYWxUaGlzLsm1QW5ndWxhcmZpcmVJbnN0YW5jZUNhY2hlLnNldChjYWNoZUtleSwgW25ld0luc3RhbmNlLCAuLi5hcmdzXSk7XG4gICAgcmV0dXJuIG5ld0luc3RhbmNlO1xuICB9XG59XG5cbmNvbnN0IEZJUkVCQVNFX0FQUF9QUk9WSURFUiA9IHtcbiAgcHJvdmlkZTogRmlyZWJhc2VBcHAsXG4gIHVzZUZhY3Rvcnk6IMm1ZmlyZWJhc2VBcHBGYWN0b3J5LFxuICBkZXBzOiBbXG4gICAgRklSRUJBU0VfT1BUSU9OUyxcbiAgICBOZ1pvbmUsXG4gICAgW25ldyBPcHRpb25hbCgpLCBGSVJFQkFTRV9BUFBfTkFNRV1cbiAgXVxufTtcblxuQE5nTW9kdWxlKHtcbiAgcHJvdmlkZXJzOiBbRklSRUJBU0VfQVBQX1BST1ZJREVSXVxufSlcbmV4cG9ydCBjbGFzcyBBbmd1bGFyRmlyZU1vZHVsZSB7XG4gIHN0YXRpYyBpbml0aWFsaXplQXBwKG9wdGlvbnM6IEZpcmViYXNlT3B0aW9ucywgbmFtZU9yQ29uZmlnPzogc3RyaW5nIHwgRmlyZWJhc2VBcHBDb25maWcpOiBNb2R1bGVXaXRoUHJvdmlkZXJzPEFuZ3VsYXJGaXJlTW9kdWxlPiB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5nTW9kdWxlOiBBbmd1bGFyRmlyZU1vZHVsZSxcbiAgICAgIHByb3ZpZGVyczogW1xuICAgICAgICB7cHJvdmlkZTogRklSRUJBU0VfT1BUSU9OUywgdXNlVmFsdWU6IG9wdGlvbnN9LFxuICAgICAgICB7cHJvdmlkZTogRklSRUJBU0VfQVBQX05BTUUsIHVzZVZhbHVlOiBuYW1lT3JDb25maWd9XG4gICAgICBdXG4gICAgfTtcbiAgfVxuXG4gIC8vIHRzbGludDpkaXNhYmxlLW5leHQtbGluZTpiYW4tdHlwZXNcbiAgY29uc3RydWN0b3IoQEluamVjdChQTEFURk9STV9JRCkgcGxhdGZvcm1JZDogT2JqZWN0KSB7XG4gICAgZmlyZWJhc2UucmVnaXN0ZXJWZXJzaW9uKCdhbmd1bGFyZmlyZScsIFZFUlNJT04uZnVsbCwgcGxhdGZvcm1JZC50b1N0cmluZygpKTtcbiAgICBmaXJlYmFzZS5yZWdpc3RlclZlcnNpb24oJ2FuZ3VsYXInLCBOR19WRVJTSU9OLmZ1bGwpO1xuICB9XG59XG4iXX0=